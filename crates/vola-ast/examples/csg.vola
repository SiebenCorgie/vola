/// A simple vola file that implements a sphere, translation, coloring and union/smooth_union.


#[derive(LocalLipshitz)]
entity Sphere(radius: vec3);

concept SDF2D: vec2 -> s;
concept SDF3D: vec3 -> s;
concept Color: -> vec3;

concept MultiConcept: (vec3, s, vec3) -> vec3;

//Declares that we need the parameter `@` to define SDF3D of Sphere
impl Sphere for SDF3D(at){
     length(at) - radius
}

///Translation operation, with explicitly no identity implementation
#[define(no_identity)]
operation Translate(trans: vec3);

//declares that `translate` takes a sub-expression and the
//field
impl Translate<sub> for SDF3D(at){
    at = at - trans;
    eval sub.SDF3D(at)
}

///Simple union operation
operation Union();
impl Union<left, right> for SDF3D(at) {
    let left = eval l.SDF3D(at);
    let right = eval r.SDF3D(at);
    let new_result = min(left, right);
    new_result
}

//SmoothUnion
operation SmoothUnion(suradius: s);
impl SmoothUnion<left, right> for SDF3D(at){
    let l = eval left.SDF3D(at);
    let r = eval right.SDF3D(at);
    let h = clamp( 0.5 + 0.5 * (r-l) / suradius, 0.0, 1.0);
    let dist = mix(l, r, h) * - suradius * h * (1.0 - h);
    dist
}

//Color overwrite operation
operation ColorOw(owcol: vec3);
impl ColorOw<sub> for Color{
    eval sub.Color();
    owcol
}


//Some reusable field definition
define subField(trans: vec3){
    csg sphere = Sphere(3.0);

    Union(){
        Translate(trans){
            Sphere(2.0)
        }
    }{
        Box([1.0, 0.0, 3.0])
    }
}

//Export interface of the SDF
export myField(p: vec3, translation: vec3){
    let some_formula = translation.x * 2.0;

    csg all_field = SmoothUnion(1.0){
        subField(translation)
    }{
        Rotate([30.0, 30.0, some_formula]){
            Round(1.0, 3, 23){
                Box([1.0, 0.5, 3.0])
            }
        }
    };

    (all_field.SDF3D(p), all_field.Color(p))
}
